package schooled.menu;

import java.awt.Color;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.function.Function;
import org.w3c.dom.Text;
import schooled.Game;
import schooled.Window;
import schooled.engines.Logger;
import schooled.engines.RenderEngine;
import schooled.entities.BasicEntity;
import schooled.entities.Entity;
import schooled.menu.TextContext.FitType;
import schooled.physics.PolygonShape;
import schooled.physics.Shape;
import schooled.physics.Vector;
import schooled.visuals.GraphicsContext;

/**
 * Entity container for holding menu object data.
 * <p></p>
 * Program written by Joseph Straceski
 * <p>
 * contact: straceski.joseph@gmail.com, https://github.com/Crepox
 */
public class MenuEntity extends Entity {

  // <editor-fold defaultstate="collapsed" desc="Variables">

  // text data variables
  // set the justification of the text within the entity area
  private Alignment alignment = Alignment.LEFT;
  // list of text contexts that make up the text of the message
  private ArrayList<TextContext> textList = new ArrayList<TextContext>();
  ;

  // border variables
  // padding variables
  private int topPadding = 0, bottomPadding = 0, leftPadding = 0, rightPadding = 0;
  private int borderSize = 0; // pixel width of the border
  private Shape borderShape; // polygon shape defining the border
  private Color borderColor; // border color
  private boolean autoUpdate = false;
  private boolean dataModified = false;
  private float lastScale = -1;
  private TextContext lastStyle = new TextContext("");

  // positioning and menu logic data
  private float width, height; // width and height data
  // flag to let the entity know if the width and height have been generated by the entity or
  //  have been set externally
  private boolean definedSize = false;
  private boolean sizeChanged = false; // flag set when the size of the menu entity has changed
  // flag to let any containers of this entity know to center it on the horizontal axis
  private boolean horizontalCenter = false;
  private boolean verticalCenter = false;
  // where the entity is drawn from relative to the entity.
  private Origin origin = Origin.CENTER;
  // origin position relative to the center of the menu entity
  private Vector originPosition = new Vector(0, 0);
  private Menu parentMenu = null; // menu entity container

  // visual data
  private float renderScale = 1.0f; // last used rendering scaling value
  private float renderWidth, renderHeight; // calculated rendering width and height
  private Color backgroundColor = null; // background color of the entity body
  // pre-calculated text rendering list
  private static Color defaultFontColor = Color.BLACK; // default font color
  private ArrayList<TextContext> renderList = new ArrayList<>();

  // </editor-fold>

  public MenuEntity setClone(MenuEntity menuEntity) {
    super.setClone(menuEntity);
    menuEntity.setAlignment(alignment);

    ArrayList<TextContext> clonedText = new ArrayList<>();

    for (TextContext textContext : textList) {
      clonedText.add(textContext.clone());
    }
    menuEntity.textList = clonedText;

    menuEntity.setTopPadding(topPadding);
    menuEntity.setBottomPadding(bottomPadding);
    menuEntity.setLeftPadding(leftPadding);
    menuEntity.setRightPadding(rightPadding);
    menuEntity.setBorderSize(borderSize);
    if (borderShape != null) {
      menuEntity.borderShape = borderShape.clone();
    }
    menuEntity.borderColor = borderColor;

    menuEntity.autoUpdate = autoUpdate;
    menuEntity.dataModified = dataModified;
    menuEntity.lastScale = lastScale;

    menuEntity.width = width;
    menuEntity.height = height;
    menuEntity.definedSize = definedSize;
    menuEntity.sizeChanged = sizeChanged;

    menuEntity.horizontalCenter = horizontalCenter;
    menuEntity.verticalCenter = verticalCenter;

    menuEntity.origin = origin;
    menuEntity.originPosition = new Vector(originPosition);

    if (parentMenu != null) {
      parentMenu.addEntity(menuEntity);
    }

    menuEntity.renderScale = renderScale;
    menuEntity.renderWidth = renderWidth;
    menuEntity.renderHeight = renderHeight;
    menuEntity.backgroundColor = backgroundColor;

    menuEntity.renderList = new ArrayList<>(renderList);

    return menuEntity;
  }

  @Override
  public BasicEntity setClone(BasicEntity entity) {
    if (entity.getClass().isInstance(this)) {
      return setClone(this.getClass().cast(entity));
    } else {
      return super.setClone(entity);
    }
  }

  public MenuEntity clone() {
    MenuEntity menuEntity = new MenuEntity(getGame());
    return setClone(menuEntity);
  }

  // <editor-fold defaultstate="collapsed" desc="Constructors">

  /**
   * Generate an empty MenuEntity object.
   *
   * @param g game instance
   */
  public MenuEntity(Game g) {
    this(g, new Vector(), null);
  }

  public MenuEntity(Entity g) {
    super(g);
    init();
  }

  /**
   * Generate a basic menu entity.
   *
   * @param g game instance
   * @param v position
   */
  public MenuEntity(Game g, Vector v) {
    this(g, v, null);
  }

  /**
   * Generate a basic menu entity.
   *
   * @param g game instance
   * @param v position
   * @param s shape
   */
  public MenuEntity(Game g, Vector v, Shape s) {
    super(g, v, s, 0);
    init();
  }

  private void init() {
    setBottomPadding(4);
    setTopPadding(4);
    setLeftPadding(4);
    setRightPadding(4);
    this.setPhysics(false);
  }

  public String toString() {
    if (textList != null) {
      return "MenuEntity[name=" + getName() + ", text=" + Arrays.toString(textList.toArray()) + "]";
    }
    return "MenuEntity[name=" + getName() + "]";
  }
  // </editor-fold>

  // <editor-fold defaultstate="collapsed" desc="Text Manipulation Methods">

  /**
   * Get the plaintext representation of the stored text data.
   *
   * @return text string
   */
  public String getText() {
    String s = "";
    for (TextContext te : textList) {
      s += te.getText();
      if (te.hasNewLine()) {
        s += "\n";
      }
    }
    return s;
  }

  /**
   * Set the text of the entity to the input string.
   * <p>
   * Uses default font.
   *
   * @param string input string
   */
  public void setText(String string) {
    clearText();
    addText(string);
  }

  public void setText(String string, Color color, Float i, Byte style) {
    clearText();
    addText(string, color, i, style);
  }

  /**
   * Set the text of the entity to the input text context.
   *
   * @param textContext text context
   */
  public void setText(TextContext textContext) {
    clearText();
    addText(textContext);
  }

  /**
   * Does the menu entity have text.
   *
   * @return true if the entity has text, false otherwise
   */
  public boolean hasText() {
    return !textList.isEmpty();
  }

  /**
   * Add text to the menu entity.
   *
   * @param string input string
   */
  public void addText(String string) {
    addText(string, null, null, null);
  }

  /**
   * Add text to the the menu entity with a color, font size, and style.
   *
   * @param string input string
   * @param color  string color
   * @param i      font size
   * @param style  font style
   */
  public void addText(String string, Color color, Float i, Byte style) {
    addText(generateTextContext(string, color, i, style));
  }

  public TextContext generateTextContext(String str, Color color, Float i, Byte style) {
    TextContext textContext = lastStyle.clone();
    textContext.setText(str);

    if (color != null) {
      textContext.setColor(color);
    }

    if (i != null && i != 0) {
      textContext.setFontSize(i);
    }

    if (style != null) {
      textContext.setStyle(style);
    }

    return textContext;
  }

  /**
   * Add a fully formatted text context to the menu entity.
   * <p>
   * Automatically splits up newlines.
   *
   * @param textContext text context
   */
  public void addText(TextContext textContext) {
    String text = textContext.getText();
    if (text != null && text.contains("\n")) {
      // split the input text on newline characters
      String[] split = text.split("\n");
      // loop through all of the split strings and add them to the text list with newlines
      for (int j = 0; j < split.length; j++) {
        TextContext te2 = textContext.clone();
        te2.setText(split[j]);
        if (j < split.length - 1) {
          te2.setNewLine(true);
        } else {
          te2.setNewLine(textContext.hasNewLine() || textContext.getText().endsWith("\n"));
        }
        ArrayList<TextContext> tcList = new ArrayList<>();
        textList.add(te2);
        dataModified = true;
      }
    } else {
      textList.add(textContext);
      dataModified = true;
    }
  }

  /**
   * Add a list of fully formatted text context to the menu entity.
   *
   * @param textList list of text contexts
   */
  public void addText(ArrayList<TextContext> textList) {
    dataModified = true;
    for (TextContext context : textList) {
      addText(context);
    }
  }

  /**
   * Remove all the text from the menu entity.
   */
  public void clearText() {
    dataModified = true;
    textList.clear();
  }

  /**
   * Get the list of texts contexts from the menu entity.
   * <p>
   * Formatted text data from the menu entity.
   *
   * @return list of text contexts
   */
  public ArrayList<TextContext> getTextList() {
    return textList;
  }

  /**
   * Get the alignment of the text in the menu area.
   *
   * @return text alignment
   */
  public Alignment getAlignment() {
    return alignment;
  }

  /**
   * Set the alignment of the text in the menu area.
   *
   * @param alignment text alignment
   */
  public void setAlignment(Alignment alignment) {
    dataModified = true;
    this.alignment = alignment;
  }

  /**
   * Set the bold state of all the text in the menu entity.
   *
   * @param state bold state
   */
  public void setTextBold(boolean state) {
    dataModified = true;
    for (TextContext te : this.getTextList()) {
      te.setBold(state);
    }
    lastStyle.setBold(state);
  }

  /**
   * Set the fit state of all the text in the menu entity.
   *
   * @param type fit type
   */
  public void setTextFit(FitType type) {
    dataModified = true;
    for (TextContext te : this.getTextList()) {
      te.setFit(type);
    }
    lastStyle.setFit(type);
  }

  /**
   * Set the font size of all the text in the menu entity.
   *
   * @param size font size
   */
  public void setFontSize(float size) {
    dataModified = true;
    for (TextContext te : this.getTextList()) {
      te.setFontSize(size);
    }
    lastStyle.setFontSize(size);
  }

  /**
   * Set the color of all the text in the menu entity.
   *
   * @param color text color
   */
  public void setTextColor(Color color) {
    dataModified = true;
    for (TextContext te : this.getTextList()) {
      te.setColor(color);
    }
    lastStyle.setColor(color);
  }

  // </editor-fold>

  // <editor-fold defaultstate="collapsed" desc="Menu Logic Methods">

  /**
   * Get the width of the menu entity.
   *
   * @return menu entity width
   */
  public float getWidth() {
    return width;
  }

  /**
   * Set the width of the menu entity.
   * <p>
   * The size of the menu entity will now be fixed.
   *
   * @param width menu entity width
   */
  public void setWidth(float width) {
    this.width = width;
    dataModified = true;
    definedSize = true;
    sizeChanged = false;
  }

  /**
   * Set the width of the menu entity.
   *
   * @param width menu entity width
   */
  private void setWidthData(float width) {
    this.width = width;
  }

  /**
   * Set the height of the menu entity.
   *
   * @return menu entity height
   */
  public float getHeight() {
    return height;
  }

  /**
   * Set the height of the menu entity.
   * <p>
   * The size of the menu entity will now be fixed.
   *
   * @param height menu entity height
   */
  public void setHeight(float height) {
    this.height = height;
    definedSize = true;
    dataModified = true;
    sizeChanged = true;
  }

  /**
   * Set the height of the menu entity.
   *
   * @param height menu entity height
   */
  private void setHeightData(float height) {
    dataModified = true;
    this.height = height;
  }

  /**
   * Get the size of the menu entity.
   * <p>
   * The size is in the form of a vector with the width as the x value and the height as the y
   * value.
   *
   * @return size of the menu entity
   */
  public Vector getSize() {
    return new Vector(getWidth(), getHeight());
  }

  /**
   * Set the size of the menu entity.
   * <p>
   * The size of the menu entity will now be fixed.
   *
   * @param v fixed size
   */
  public void setSize(Vector v) {
    setWidth(v.getXi());
    setHeight(v.getYi());
  }

  /**
   * Should the menu entity be centered horizontally in the menu container.
   *
   * @return true if it should be centered, false otherwise
   */
  public boolean isHorizontalCenter() {
    return horizontalCenter;
  }


  /**
   * Set if the menu entity should be centered horizontally in the menu container.
   *
   * @param horizontalCenter horizontal state
   */
  public void setHorizontalCenter(boolean horizontalCenter) {
    this.horizontalCenter = horizontalCenter;
    dataModified = true;
  }

  public boolean isVerticalCenter() {
    return verticalCenter;
  }

  public void setVerticalCenter(boolean verticalCenter) {
    dataModified = true;
    this.verticalCenter = verticalCenter;
  }

  /**
   * Calculate the menu position relative to the internal menu position.
   *
   * @return menu entity position
   */
  @Override
  public Vector getPosition() {
    return convertPos(super.getPosition());
  }

  /**
   * Get the raw location of the menu entity.
   *
   * @return raw position
   */
  public Vector getDefaultPos() {
    return super.getPosition();
  }

  /**
   * Convert the raw input position to a position relative to the menu entity.
   * <p>
   * The origin position and the origin enum work in unison in this method. The origin position is a
   * position relative to the center of the menu entity that defines where the menu entity's raw
   * position is referencing on itself. An origin position of (10, 10) and a entity position of
   * (100, 100) will draw the menu entity centered at (110, 110) as if it were being drawn at (100,
   * 100) from a point (10, 10) relative to the center of the menu entity. The origin enum is a way
   * to add an origin position relative to the size of the menu entity. The origin enum calculation
   * is added to the origin position.
   *
   * @param v input vector
   * @return relative drawing position
   */
  public Vector convertPos(Vector v) {
    Vector newV = v.addi(getOriginPosition());
    float newHeight = getHeight() / 2;
    float newWidth = getWidth() / 2;
    switch (origin) {
      case TOP_LEFT:
        return newV.addi(new Vector(newWidth, newHeight));
      case TOP_RIGHT:
        return newV.addi(new Vector(-newWidth, newHeight));
      case TOP:
        return newV.addi(new Vector(0, newHeight));
      case LEFT:
        return newV.addi(new Vector(newWidth, 0));
      case RIGHT:
        return newV.addi(new Vector(-newWidth, 0));
      case BOTTOM_LEFT:
        return newV.addi(new Vector(newWidth, -newHeight));
      case BOTTOM:
        return newV.addi(new Vector(0, -newHeight));
      case BOTTOM_RIGHT:
        return newV.addi(new Vector(-newWidth, -newHeight));
      default:
        return newV;
    }
  }

  /**
   * Get the origin of the entity.
   * <p>
   * {@link MenuEntity convertPos} for more information on the origin.
   *
   * @return origin value
   */
  public Origin getOrigin() {
    return origin;
  }

  /**
   * Set the origin of the entity.
   * <p>
   * {@link MenuEntity convertPos} for more information on the origin.
   *
   * @param origin origin value
   */
  public void setOrigin(Origin origin) {
    this.origin = origin;
  }

  /**
   * Get the origin position of the entity.
   * <p>
   * {@link MenuEntity convertPos} for more information on the origin position.
   *
   * @return origin position
   */
  public Vector getOriginPosition() {
    return originPosition;
  }

  /**
   * Set the origin position of the entity.
   * <p>
   * {@link MenuEntity convertPos} for more information on the origin position.
   *
   * @param originPosition origin position
   */
  public void setOriginPosition(Vector originPosition) {
    this.originPosition = originPosition;
  }

  /**
   * Get the menu container for the menu entity.
   *
   * @return menu container
   */
  public Menu getParentMenu() {
    return parentMenu;
  }

  /**
   * Set the menu container for the menu entity.
   *
   * @param parentMenu menu container
   */
  public void setParentMenu(Menu parentMenu) {
    this.parentMenu = parentMenu;
  }

  @Override
  public void preRender(Object graphicsContext) {
    super.preRender(graphicsContext);
    if (getGame() == null) {
      updateVisual(Window.DEFAULT_GRAPHICS_CONTEXT);
    } else {
      updateVisual(getGame().getVisualContext(), getGame().getMenuScreenScale());
    }
  }


  /**
   * Called when the menu container of the entity is being unloaded.
   */
  public void unload() {
    updateCycle();
  }

  /**
   * Calculate the sizes of menu entity objects relative to the render scale value.
   *
   * @param gc graphics context
   */
  public void updateVisual(Object gc) {
    updateVisual(gc, renderScale);
  }

  public void forceUpdate() {
    dataModified = true;
  }

  /**
   * Calculate and set menu entity sizes and shapes based on an input scale.
   * <p>
   * Handles if the entity has a defined size. This method must be called before drawing the menu
   * entity.
   *
   * @param gc    graphics context
   * @param scale input scale
   */
  public void updateVisual(Object gc, float scale) {
    if (scale != lastScale || dataModified) {
      Logger.pushDebugTime("render_list_tot");
      float[] size = calculateTextSize(gc, scale);
      Logger.pushDebugTime("render_list_tot");

      Logger.pushDebugTime("render_list_shape");
      if (!definedSize) {
        setWidthData(size[0] / scale);
        setHeightData(size[1] / scale);
        setRenderWidth(size[0]);
        setRenderHeight(size[1]);

        setShape(new PolygonShape(getWidth(), getHeight()));
        generateBorderShape();
      } else {
        setRenderWidth(getWidth() * scale);
        setRenderHeight(getHeight() * scale);

        if (sizeChanged) {
          setShape(new PolygonShape(getWidth(), getHeight()));
          generateBorderShape();
          sizeChanged = false;
        }
      }

      dataModified = false;
      lastScale = scale;
      Logger.pushDebugTime("render_list_shape");
    }
  }

  // <editor-fold defaultstate="collapsed" desc="Sizing Helper Methods">

  /**
   * Find the index of a splitting space.
   * <p>
   * Find the index of a space in the text that when split on, the width of the first half of the
   * text will not exceed the interior width of the text area when added to the current width.
   * <p>
   * If no index is found, -1 is returned.
   *
   * @param gc          graphics context
   * @param cWidth      current width
   * @param textContext text
   * @param inWidth     interior width
   * @return space index if one exists, -1 otherwise
   */
  private int findSpaceIndex(Object gc, float cWidth, TextContext textContext, float inWidth) {
    int index = -1;
    int spaceIndex = -1;

    String master = textContext.getText();
    TextContext clone = textContext.clone();

    while ((spaceIndex = master.indexOf(' ', spaceIndex + 1)) >= 0) {
      clone.setText(master.substring(0, spaceIndex));
      RenderEngine.calculateTextSize(gc, clone);

      if (cWidth + clone.getWidth() < inWidth) {
        index = spaceIndex;
      } else {
        return index;
      }
    }

    return index;
  }

  /**
   * Find the last space in a previous text on the current line.
   * <p>
   * Searches backwards in the text list until a space is found. Returns the index in the master
   * list where it was located. If the search reaches a newline or the end of the list before it
   * finds a space return -1.
   *
   * @param tList     master text list reference
   * @param mainIndex current index
   * @return index of the text with a space, if none exist -1
   */
  private int searchSpace(ArrayList<TextContext> tList, int mainIndex) {
    for (int revIndex = 1; revIndex <= mainIndex; revIndex++) {
      TextContext newContext = tList.get(mainIndex - revIndex);
      if (newContext.hasNewLine()) {
        return -1;
      }

      if (newContext.getText().indexOf(' ') != -1) {
        return mainIndex - revIndex;
      }
    }
    return -1;
  }

  /**
   * Search the referenced text for a split that makes it fit within the text area.
   * <p>
   * Split the referenced text right before the width is exceeded. Add both splits to the tcList.
   *
   * @param gc        graphics context
   * @param tcList    text list
   * @param tcIndex   text index
   * @param lineWidth previous width of the line
   * @param inWidth   inner width of the text area
   */
  private void searchSplit(Object gc, ArrayList<TextContext> tcList, int tcIndex,
      float lineWidth, float inWidth) {
    Function<TextContext, Integer> func = (TextContext clonedInstance) -> {
      String masterText = clonedInstance.getText();
      return indexSearch(masterText.length(),
          (k) -> {
            clonedInstance.setText(masterText.substring(0, k));
            RenderEngine.calculateTextSize(gc, clonedInstance);
            return Float.compare(lineWidth + clonedInstance.getWidth(), inWidth);
          });
    };

    split(gc, func, tcList, tcIndex);
  }

  /**
   * Split the text at the given string index.
   * <p>
   * Split the referenced text right before the width is exceeded. Add both splits to the text
   * list.
   *
   * @param gc      graphics context
   * @param sIndex  string index
   * @param tcList  text list
   * @param tcIndex text list index
   */
  private void split(Object gc, int sIndex, ArrayList<TextContext> tcList, int tcIndex) {
    split(gc, (TextContext tc) -> sIndex, tcList, tcIndex);
  }

  /**
   * Split the text at the index gained by passing it into a function.
   *
   * @param gc       graphics context
   * @param function index
   * @param tcList   text list
   * @param tcIndex  text list index
   */
  private void split(Object gc, Function<TextContext, Integer> function,
      ArrayList<TextContext> tcList, int tcIndex) {
    TextContext newContext = tcList.get(tcIndex);
    TextContext afterContext = newContext.clone();
    String newText = newContext.getText();
    int sIndex = function.apply(afterContext);

    afterContext.setText(trimBefore(newText.substring(sIndex)));
    RenderEngine.calculateTextSize(gc, afterContext);

    newContext.setText(trimAfter(newText.substring(0, sIndex)));
    newContext.setNewLine(true);
    RenderEngine.calculateTextSize(gc, newContext);

    tcList.add(tcIndex + 1, afterContext);
  }

  /**
   * Preform a binary search on the list of indexes from 0 to the length - 1.
   * <p>
   * Use the test function to find the correct index between not crossing the index list to crossing
   * it.
   *
   * @param length number of indexes
   * @param test   search function
   * @return crossing index
   */
  private int indexSearch(int length, Function<Integer, Integer> test) {
    int first = 0;
    int last = length - 1;
    int middle = (first + last) / 2;

    while (first < last) {
      int result = test.apply(middle);
      if (result == 0) {
        return middle;
      } else if (result < 0) {
        first = middle + 1;
      } else {
        last = middle - 1;
      }
      middle = (first + last) / 2;
    }

    if (test.apply(middle) == 1) {
      return middle - 1;
    }

    return middle;
  }

  /**
   * Trim the spaces before the text.
   *
   * @param s text
   * @return trimmed text
   */
  private String trimBefore(String s) {
    while (s.startsWith(" ") && s.length() > 0) {
      s = s.substring(1);
    }
    return s;
  }

  /**
   * Trim the spaces after the text.
   *
   * @param s text
   * @return trimmed text
   */
  private String trimAfter(String s) {
    while (s.endsWith(" ") && s.length() > 0) {
      s = s.substring(0, s.length() - 1);
    }
    return s;
  }

  // </editor-fold>

  /**
   * Calculate the size of the menu entity with an input scale.
   * <p>
   * Uses word processing logic to fit the menu text inside the entity is it has a static width.
   *
   * @param gc    graphics context
   * @param scale scale to apply to the elements of the menu entity
   * @return width and height of the menu entity
   */
  public float[] calculateTextSize(Object gc, float scale) {
    // variables for width and height
    float areaWidth = 0, areaHeight = 0;
    float lineWidth = 0, lineHeight = 0, lineAscent = 0;
    float inWidth = (getWidth() - getHorizontalPadding()) * scale;
    float inHeight = (getHeight() - getVerticalPadding()) * scale;

    // flag to tell if the the end of the text list has been reached and (reduces objects made)
    boolean end = false;

    // create a list to store all of the text contexts in the line
    ArrayList<TextContext> lineList = new ArrayList<>();
    ArrayList<TextContext> tList = new ArrayList<>();
    renderList.clear(); // clear out the old render list

    int eIdx = -1;
    int setLine = -1;
    float rLoc = -1;
    int lIdx = 0;
    int tIdx = 0;
    int rIdx = 0;
    float last = 0;
    int len = 0;
    TextContext tc = null;
    Vector uLoc = null;
    boolean flag = false;

    if (this instanceof TextArea) {
      eIdx = ((TextArea) this).getEditIndex();
      flag = true;

      int temp = ((TextArea) this).getLineIndex();
      int temp2 = ((TextArea) this).getUpdateLineIndex();
      if (temp != -1 && temp2 != -1 && temp != temp2) {
        setLine = temp2;
        rLoc = ((TextArea) this).getLastRight();
      }

      Vector updateLocation = ((TextArea) this).getUpdateLocation();
      if (updateLocation != null) {
        uLoc = updateLocation;
      }
    }

    // create a clone of the text list, this allows us to modify the text and create a render list
    for (TextContext original : getTextList()) {
      TextContext clonedEffect = original.clone(); // clone
      clonedEffect.scaleFontSize(scale); // scale the font by the rendering scale
      RenderEngine.calculateTextSize(gc, clonedEffect); // calculate the size of the text
      tList.add(clonedEffect); // add the cloned effect to the temp list
    }

    for (int i = 0; i < tList.size(); i++) {
      TextContext te = tList.get(i); // get the text at the given index

      if (definedSize) {
        // if the entity has a specific size modify the text effect to fit the text area space
        if (lineWidth + te.getWidth() > inWidth) {
          // if the width of the current text causes the line to be larger than the text area width,
          //  modify the list of text effects to fit within the area width

          // get a space index that will divide the text to fit the entity width
          int sIndex = findSpaceIndex(gc, lineWidth, te, inWidth);
          if (sIndex == -1) {
            // if no space was found, try to find a text effect on the same line that has a space
            sIndex = searchSpace(tList, i);

            if (sIndex != -1) {
              // if a valid text effect has been found, use the last space in it to make line split
              //  (this works because all previous text effects must fit in the line already)
              split(gc, tList.get(sIndex).getText().lastIndexOf(' '), tList, sIndex);

              // go back to the first text in the line and re-calculate the line width and height
              i -= (lineList.size());
              lineList.clear();
              lineWidth = 0;
              lineHeight = 0;
              lineAscent = 0;

              te = tList.get(i); // redo the calculations on the first text effect
            } else {
              // if there are no valid spaces, divide the text at whatever character comes directly
              //  before exceeding the area width
              searchSplit(gc, tList, i, lineWidth, inWidth);
            }
          } else {
            // if a space index is found, split the text at that index
            split(gc, sIndex, tList, i);
          }
        }

        if (areaHeight + te.getHeight() > inHeight) {
          // if the line height will cause the text effect to exceed the area height, break
          break;
        }

        if (lineWidth + te.getWidth() + te.getAdvance() > inWidth) {
          // if the advance will now cause the text effect to exceed the width make this a new line
          te.setNewLine(true);
        }
      }

      lineList.add(te); // add the current text to the line list
      lineWidth += te.getWidth(); // add the text width to the line width

      lineAscent = Math.min(lineAscent, te.getAscent());
      lineHeight = Math.max(lineHeight, te.getHeight()); // find the max line height

      float lH = areaHeight + lineHeight;

      if ((end = i >= tList.size() - 1) || te.hasNewLine()) {
        // if the text is a newline or the last text context
        if (!end && (!definedSize || areaHeight + getBottomPadding() * scale <= inHeight)) {
          // if the line is not the end of the text add padding between lines of text
          //  also check if spacing is will cause it to be outside of the set height
          lineHeight += getBottomPadding() * scale;
        }

        areaWidth = Math.max(lineWidth, areaWidth); // calculated as the maximum line width
        areaHeight += lineHeight; // add the line height to the area height

        float tW = 0;
        for (TextContext textContext : lineList) {
          tc = textContext;

          // loop through all text contexts in the current line list to set the line data
          //  also add them to the render list because all the text contexts here are finalized
          tc.setLineAscent(lineAscent);
          tc.setLineHeight(lineHeight);
          tc.setLineWidth(lineWidth);

          len = tc.getText().length() + (tc.hasNL() ? 1 : 0);

          if (flag) {
            Vector eLoc = new Vector(getLeftPad() * scale + tW, lH + getTopPad() * scale);

            if (uLoc != null) {
              if (uLoc.getY() < last) {
                flag = setEditInfo(eLoc, tIdx, lIdx, rIdx);
              } else if (last <= uLoc.getY() && uLoc.getY() < lH) {
                flag = findEditInfo(gc, tc, eLoc, uLoc.getX(), tIdx, lIdx, rIdx);
              }
            } else if (setLine != -1) {
              if (setLine == lIdx) {
                flag = findEditInfo(gc, tc, eLoc, rLoc, tIdx, lIdx, rIdx);
              }
            } else if (eIdx == 0) {
              flag = setEditInfo(eLoc, null, lIdx, rIdx);
            } else if (len > eIdx && eIdx > -1) {
              TextContext cTC = tc.clone();
              cTC.setText(tc.getText().substring(0, Math.min(tc.getText().length(), eIdx)));
              RenderEngine.calculateTextSize(gc, cTC);
              flag = setEditInfo(eLoc.addi(cTC.getWidth(), 0), null, lIdx, rIdx);
            }

            if (flag) {
              setEditInfo(eLoc.addi(tc.getWidth(), 0), null, lIdx, null);
            }

            tW += tc.getWidth() + tc.getAdvance();
          }

          eIdx -= len;
          tIdx += len;
          rIdx += len;

          renderList.add(tc);
        }

        if (!end) {
          lineList = new ArrayList<>(); // if the end has not been reached, create a new line list
          lineWidth = 0; // clear the line data
          lineHeight = 0;
          lIdx++;
          rIdx = 0;
          last = lH;
        }
      } else {
        lineWidth += te.getAdvance(); // add an advance spacing between text effects
      }
    }

    if (this instanceof TextArea) {
      ((TextArea) this).setUpdateLineIndex(-1);
      if (flag && tc != null) {
        ((TextArea) this).setEditIndex(tIdx);
      }
      ((TextArea) this).setUpdateLocation(null);
    }

    // couples the render scale setting with the loading of the list
    renderScale = scale;

    // return the sizes with the scaled padding values added on
    float iWidth = areaWidth + ((getLeftPad() + getRightPadding()) * scale);
    float iHeight = areaHeight + ((getTopPad() + getBottomPadding()) * scale);
    return new float[]{iWidth, iHeight};
  }

  public boolean setEditInfo(Vector eLoc, Integer idx, Integer lIdx, Integer rIdx) {
    TextArea ta = (TextArea) this;
    ta.setEditIndex(idx);
    ta.setEditLoc(eLoc);
    ta.setLineIndex(lIdx);
    ta.setRowIndex(rIdx);

    return false;
  }

  public boolean findEditInfo(Object gc, TextContext tc, Vector eLoc, float xLim, int i, int lIdx, int rIdx) {
    int index = tc.getText().length();
    if (eLoc.getX() + tc.getWidth() > xLim) {
      TextContext cTC = tc.clone();
      while (eLoc.getX() + cTC.getWidth() > xLim && index > 0) {
        index--;
        cTC.setText(tc.getText().substring(0, index));
        RenderEngine.calculateTextSize(gc, cTC);
      }
      return setEditInfo(eLoc.addi(new Vector(cTC.getWidth(), 0)), i + index, lIdx, rIdx);
    } else if (eLoc.getX() + tc.getWidth() <= xLim && tc.hasNL()) {
      return setEditInfo(eLoc.addi(new Vector(tc.getWidth(), 0)), i + index, lIdx, rIdx);
    }

    return true;
  }

  // </editor-fold>

  // <editor-fold defaultstate="collapsed" desc="Border/Padding Methods">

  public float getTopPad() {
    return topPadding;
  }

  public void setTopPadding(int topPadding) {
    dataModified = true;
    this.topPadding = topPadding;
  }

  public float getBottomPadding() {
    return bottomPadding;
  }

  public void setBottomPadding(int bottomPadding) {
    dataModified = true;
    this.bottomPadding = bottomPadding;
  }

  public float getLeftPad() {
    return leftPadding;
  }

  public void setLeftPadding(int leftPadding) {
    dataModified = true;
    this.leftPadding = leftPadding;
  }

  public float getRightPadding() {
    return rightPadding;
  }

  public void setRightPadding(int rightPadding) {
    dataModified = true;
    this.rightPadding = rightPadding;
  }

  /**
   * Set a standard padding for all borders.
   *
   * @param border padding
   */
  public void setPadding(int border) {
    setTopPadding(border);
    setBottomPadding(border);
    setRightPadding(border);
    setLeftPadding(border);
  }

  /**
   * Get the combination of top and bottom padding.
   *
   * @return total padding
   */
  public float getHorizontalPadding() {
    return getLeftPad() + getRightPadding();
  }

  /**
   * Get the combination of left and right padding.
   *
   * @return total padding
   */
  public float getVerticalPadding() {
    return getLeftPad() + getRightPadding();
  }

  /**
   * Get the border size.
   *
   * @return border point size
   */
  public float getBorderSize() {
    return borderSize;
  }

  /**
   * Set the border size.
   *
   * @param borderSize border point size
   */
  public void setBorderSize(int borderSize) {
    dataModified = true;
    this.borderSize = borderSize;
  }

  /**
   * Get the color of the border.
   *
   * @return the border color
   */
  public Color getBorderColor() {
    return borderColor;
  }

  /**
   * Set the color of the border.
   *
   * @param borderColor border color
   */
  public void setBorderColor(Color borderColor) {
    dataModified = true;
    this.borderColor = borderColor;
  }

  /**
   * Set the border color and size.
   *
   * @param c color
   * @param i size
   */
  public void setBorder(Color c, int i) {
    dataModified = true;
    borderColor = c;
    borderSize = i;
  }

  /**
   * Does the menu entity have a border.
   *
   * @return true if the menu entity has a border, false otherwise
   */
  public boolean hasBorder() {
    return borderSize > 0 && borderColor != null;
  }

  /**
   * Get the border shape.
   *
   * @return border shape
   */
  public Shape getBorderShape() {
    return borderShape;
  }

  /**
   * Use a scaling algorithm to generate a border shape from the current width and height.
   */
  public void generateBorderShape() {
    if (getShape() instanceof PolygonShape) {
      ArrayList<Vector> vList = ((PolygonShape) getShape()).getVertices();

      ArrayList<Vector[]> mathList = new ArrayList<>();
      ArrayList<Vector> finalList = new ArrayList<>();

      // generate border line data
      Vector v2 = vList.get(vList.size() - 1);
      for (Vector v1 : vList) {
        Vector[] pair = new Vector[2];

        Vector a2b = v2.subi(v1);
        Vector perp = new Vector(-a2b.getY(), a2b.getX());
        perp.normalize();

        perp.scale(-getBorderSize());
        Vector pos = v1.addi(perp);
        pair[0] = pos;
        pair[1] = a2b;

        mathList.add(pair);

        v2 = v1;
      }

      // connect border lines
      Vector[] vp2 = mathList.get(mathList.size() - 1);
      for (Vector[] vp1 : mathList) {

        Vector vp1TOvp2 = vp2[0].subi(vp1[0]);
        float dp1 = Vector.cross(vp1TOvp2, vp2[1]);
        float dp2 = Vector.cross(vp1[1], vp2[1]);

        float t1 = dp1 / dp2;
        finalList.add(vp1[0].addScaledi(vp1[1], t1));

        vp2 = vp1;
      }

      // set border shape
      PolygonShape a = ((PolygonShape) getShape()).clone();
      a.setTraceShape(new PolygonShape(finalList));
      borderShape = a;
    }
  }

  /**
   * Shift the list by a given offset.
   * <p>
   * Implies the list is like a cycle buffer and pushes the last index to the first and vice versa.
   *
   * @param list   list
   * @param offset cycle offset
   * @return modified list
   */
  public ArrayList<Vector> reorderArrayList(ArrayList<Vector> list, int offset) {
    ArrayList<Vector> finalList = new ArrayList<Vector>();
    for (int i = 0; i < list.size(); i++) {
      int index = i + offset;
      if (index > list.size() - 1) {
        index = index - (list.size());
      }

      if (index < 0) {
        index = (list.size() - 1);
      }

      finalList.add(list.get(index));
    }
    return finalList;
  }

  // </editor-fold>

  // <editor-fold defaultstate="collapsed" desc="Visual Methods">

  /**
   * Get the background color of the menu entity.
   *
   * @return background color
   */
  public Color getBackgroundColor() {
    return backgroundColor;
  }

  /**
   * Set the background color of the menu entity.
   *
   * @param backgroundColor background color
   */
  public void setBackgroundColor(Color backgroundColor) {
    dataModified = true;
    this.backgroundColor = backgroundColor;
  }

  /**
   * Does the menu entity have a background color.
   *
   * @return true if it has one, false otherwise
   */
  public boolean hasBackgroundColor() {
    return this.backgroundColor != null;
  }

  public Color getDefaultFontColor() {
    return defaultFontColor;
  }

  public void setDefaultFontColor(Color defaultFontColor) {
    dataModified = true;
    MenuEntity.defaultFontColor = defaultFontColor;
  }

  /**
   * Get the top padding value scaled by the render scalar.
   *
   * @return scaled top padding
   */
  public float getRenderTopPadding() {
    return topPadding * renderScale;
  }

  /**
   * Get the bottom padding value scaled by the render scalar.
   *
   * @return scaled top padding
   */
  public float getRenderBottomPadding() {
    return bottomPadding * renderScale;
  }

  /**
   * Get the left padding value scaled by the render scalar.
   *
   * @return scaled top padding
   */
  public float getRenderLeftPadding() {
    return leftPadding * renderScale;
  }

  /**
   * Get the right padding value scaled by the render scalar.
   *
   * @return scaled top padding
   */
  public float getRenderRightPadding() {
    return rightPadding * renderScale;
  }

  /**
   * Get the render width of the menu area.
   *
   * @return render width
   */
  public float getRenderWidth() {
    return renderWidth;
  }

  /**
   * Set the render width of the menu area.
   *
   * @param renderWidth render width
   */
  public void setRenderWidth(float renderWidth) {
    this.renderWidth = renderWidth;
  }

  /**
   * Get the render width of the menu area.
   *
   * @return render width
   */
  public float getRenderHeight() {
    return renderHeight;
  }

  /**
   * Set the render height of the menu area.
   *
   * @param renderHeight render height
   */
  public void setRenderHeight(float renderHeight) {
    this.renderHeight = renderHeight;
  }

  /**
   * Get the render sizes as a vector.
   *
   * @return render width and height
   */
  public Vector getRenderSize() {
    return new Vector(getRenderWidth(), getRenderHeight());
  }

  /**
   * Get the render border size.
   *
   * @return render border size
   */
  public float getRenderBorderSize() {
    return borderSize * renderScale;
  }


  /**
   * Get the render text list.
   *
   * @return pre-generated render text list.
   */
  public ArrayList<TextContext> getRenderTextList() {
    return renderList;
  }

  /**
   * Set the render text list.
   *
   * @param renderTextList pre-generated render text list.
   */
  public void setRenderTextList(ArrayList<TextContext> renderTextList) {
    dataModified = true;
    this.renderList = renderTextList;
  }

  // </editor-fold>
}
